<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aviator</title>
<style>
  :root{
    --bg:#0b0b0b;
    --panel:#111;
    --accent:#00b04f;
    --muted:#888;
    --yellow:#f0c000;
    --red:#d9534f;
    --blue:#2a9df4;
    --green:#2ecc71;
    --white:#fff;
    --card-radius:12px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--white)}
  .app{
    display:flex;
    flex-direction:column;
    min-height:100vh;
  }
  /* Loading */
  #loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.65);z-index:9999}
  #loading .box{background:#07121a;padding:22px;border-radius:12px;text-align:center}
  /* Header */
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;background:transparent}
  header h1{margin:0;font-size:18px;letter-spacing:1px}
  header .userbar{display:flex;gap:8px;align-items:center}
  /* Main layout */
  .container{padding:10px;display:flex;flex-direction:column;gap:10px;flex:1;}
  /* Top bar: withdraw / small counter / balance */
  .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .topbar .left{display:flex;gap:8px;align-items:center}
  .btn-withdraw{background:var(--yellow);color:#000;padding:8px 12px;border-radius:10px;font-weight:700}
  .small-counter{width:44px;height:44px;border-radius:50%;background:#000;display:flex;align-items:center;justify-content:center;flex-direction:column;border:2px solid #111}
  .small-counter .num{color:var(--blue);font-weight:700}
  .bal{background:var(--green);padding:8px 12px;border-radius:10px;color:#022; font-weight:700}
  /* Aviator box */
  .aviator{
    background:linear-gradient(180deg,#090909,#0f0f0f);
    border-radius:14px;
    padding:8px;
    position:relative;
    overflow:hidden;
  }
  .plane-box{
    background:linear-gradient(180deg,#050505,#0b0b0b);
    border-radius:12px;
    height:46vh;
    min-height:320px;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
  }
  /* REMOVED PLANE ANIMATION: Hiding canvas completely */
  canvas#planeCanvas{width:100%;height:100%;display:none;border-radius:10px}
  .live-mult{position:absolute;left:50%;transform:translateX(-50%);top:18%;background:transparent;padding:6px 10px;border-radius:8px;font-weight:800;font-size:20px}
  .flight-msg{position:absolute;left:12px;top:12px;background:transparent;color:var(--muted);font-size:12px}
  /* bottom controls */
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end;justify-content:space-between;padding-top:8px}
  .big-left{display:flex;flex-direction:column;gap:8px;flex:1;min-width:170px}
  .big-right{display:flex;flex-direction:column;gap:8px;width:220px;max-width:40%}
  .stake-box, .bet-box{background:#07121a;padding:10px;border-radius:10px}
  .stake-box input{width:100%;padding:8px;border-radius:8px;border:1px solid #222;background:transparent;color:var(--white);font-size:16px}
  .bet-button{padding:12px;border-radius:10px;text-align:center;font-weight:800;cursor:pointer}
  .bet-button.bet{background:var(--green);color:#022}
  .bet-button.yellow{background:var(--yellow);color:#000}
  .bet-button.cancel{background:var(--red);color:#fff}
  .deposit-btn{background:#0a5;padding:8px 10px;border-radius:8px;color:#022;font-weight:700}
  .past-list{display:flex;gap:6px;align-items:center;overflow:auto;padding-top:6px}
  .past-item{background:#111;border-radius:8px;padding:6px 8px;font-weight:700;font-size:13px}
  .footer-note{font-size:12px;color:var(--muted);text-align:center;padding:10px}
  /* Login/Register modal */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:1000}
  .card{background:#071421;padding:16px;border-radius:12px;color:var(--white);width:92%;max-width:420px}
  .form-row{display:flex;flex-direction:column;margin-bottom:10px}
  .form-row label{font-size:13px;color:var(--muted);margin-bottom:6px}
  .form-row input{padding:10px;border-radius:8px;border:1px solid #222;background:transparent;color:var(--white)}
  .row-h{display:flex;gap:8px}
  .small{font-size:13px;color:var(--muted)}
  .linkish{color:var(--blue);cursor:pointer;font-weight:700}
  .top-controls{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  /* responsive tweaks */
  @media (max-width:640px){
    .big-right{width:48%}
    .plane-box{height:50vh}
  }
</style>
</head>
<body>
<div id="loading"><div class="box"><strong>Loading Aviator...</strong><div style="height:10px"></div><small style="color:#9fb">Initializing</small></div></div>

<div class="app" id="app" style="display:none">
  <header>
    <h1>Aviator</h1>
    <div class="userbar">
      <div id="sessionName" style="display:none">Welcome <span id="userNameTxt"></span></div>
      <button id="loginBtn" class="linkish">Login / Register</button>
      <button id="logoutBtn" style="display:none" class="linkish">Logout</button>
    </div>
  </header>

  <main class="container">
    <div class="topbar">
      <div class="left">
        <button class="btn-withdraw" id="withdrawBtn">Withdraw</button>
        <div class="small-counter">
          <div style="font-size:11px;color:var(--muted)">#</div>
          <div class="num" id="genIndex">0</div>
        </div>
      </div>
      <div class="bal" id="balanceBox">1000</div>
    </div>

    <section class="aviator">
      <div class="flight-msg" id="roundStateMsg">Waiting...</div>
      <div class="plane-box">
        <canvas id="planeCanvas"></canvas>
        <div class="live-mult" id="liveMultiplier">×1.00</div>
      </div>

      <div style="padding:8px 2px;">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-size:13px;color:var(--muted)">Past 10 multipliers</div>
          <div id="countdownBox" style="font-size:13px;color:var(--muted)">Round time: <span id="roundTimer">--</span></div>
        </div>
        <div class="past-list" id="pastList" style="margin-top:6px"></div>
      </div>
    </section>

    <section class="controls">
      <div class="big-left">
        <div class="stake-box">
          <div style="font-size:13px;color:var(--muted)">Stake</div>
          <input id="stakeInput" type="number" placeholder="Enter stake amount" min="1" />
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="maxBtn" class="deposit-btn">Max</button>
            <button id="plus10" class="deposit-btn">+10</button>
            <button id="plus50" class="deposit-btn">+50</button>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;">
          <div class="bet-box" style="flex:1">
            <div style="font-size:12px;color:var(--muted)">Bet</div>
            <div id="betAmount" style="font-weight:800;font-size:18px">0</div>
          </div>

          <div id="betButton" class="bet-button bet" style="width:150px;display:flex;align-items:center;justify-content:center">Bet</div>
        </div>
      </div>

      <div class="big-right">
        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div style="font-size:13px;color:var(--muted)">Deposit</div>
          <div class="deposit-btn" id="depositBtn">Deposit</div>
        </div>
        <div style="margin-top:8px">
          <div style="font-size:13px;color:var(--muted)">Status</div>
          <div id="statusBox" style="background:#07121a;padding:8px;border-radius:8px;margin-top:6px">Idle</div>
        </div>
      </div>
    </section>

    <div class="footer-note">We keep your data secure and confidential. (Win_Big)</div>
  </main>
</div>

<div id="authOverlay" class="overlay" style="display:none">
  <div class="card">
    <div class="top-controls">
      <strong id="authTitle">Login</strong>
      <div><button id="closeAuth" class="linkish">Close</button></div>
    </div>

    <div id="loginForm">
      <div class="form-row">
        <label>Phone number</label>
        <input id="loginPhone" placeholder="07XXXXXXXX" />
      </div>
      <div class="form-row">
        <label>Password</label>
        <input id="loginPass" type="password" />
      </div>
      <div style="display:flex;gap:8px;justify-content:space-between">
        <div class="small linkish" id="showRegister">Create account</div>
        <button id="doLogin" class="deposit-btn">Login</button>
      </div>
      <div style="margin-top:8px;color:var(--muted);font-size:13px">Save password to browser is optional (use browser prompt).</div>
    </div>

    <div id="registerForm" style="display:none">
      <div class="form-row">
        <label>Full name</label>
        <input id="regName" placeholder="Your name" />
      </div>
      <div class="form-row">
        <label>Phone number</label>
        <input id="regPhone" placeholder="07XXXXXXXX" />
      </div>
      <div class="row-h">
        <div style="flex:1" class="form-row">
          <label>Password</label>
          <input id="regPass" type="password" />
        </div>
        <div style="flex:1" class="form-row">
          <label>Confirm</label>
          <input id="regPass2" type="password" />
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:space-between">
        <div class="small linkish" id="showLogin">Already have account?</div>
        <button id="doRegister" class="deposit-btn">Create</button>
      </div>
      <div style="margin-top:8px;color:var(--muted);font-size:13px">New accounts start with 1000 balance.</div>
    </div>
  </div>
</div>

<script>
/*
  Aviator single-file implementation
  - Now uses variable flight time based on constant growth rate.
  - Pre-round is fixed at 5s.
  - Accounts stored in localStorage under key 'avi_accounts'
  - Session stored in localStorage under 'avi_session' (phone)
  - Past-10 multipliers saved in localStorage 'avi_past'

  *** IMPLEMENTED FEATURE: Instantaneous Cash out -> Bet switch and Live Countdown end upon target multiplier reached. ***
*/

(() => {
  // ********** CONFIG **********
  const PRE_ROUND = 5_000;         // ms (betting countdown) - FIXED
  const BASE_RATE_MS = 1500;       // ms (Time taken for multiplier to grow to x2.718 (e)) - This sets the constant speed.
  const DEFAULT_BALANCE = 1000;
  
  // NOTE: CYCLE and FLIGHT are now dynamic based on the generated multiplier and BASE_RATE_MS
  
  const MULTIPLIERS = [
    1.27,2.14,1.03,3.82,7.41,1.56,1.11,4.27,12.49,1.24,2.71,1.09,8.35,1.63,1.02,5.42,2.03,1.18,3.54,10.83,
    1.15,1.07,6.48,2.32,1.95,1.04,1.34,9.64,1.13,3.09,1.26,4.91,2.67,1.08,1.52,1.21,14.72,1.03,2.18,1.09,
    1.88,3.47,1.06,7.22,1.24,1.11,2.97,5.84,1.04,18.93,1.27,1.18,4.48,1.06,2.54,1.77,8.92,1.39,1.08,3.63,
    1.14,1.04,22.41,1.57,2.01,1.07,4.12,6.83,1.09,1.28,3.96,2.38,1.05,1.16,15.74,1.23,1.02,9.83,2.91,1.31,
    1.18,4.34,1.47,1.06,13.56,1.09,2.26,1.04,6.37,3.04,1.07,1.12,5.78,2.79,1.03,1.61,12.84,1.05,4.53,1.07,
    1.32,6.92,1.14,1.03,24.61,1.19,2.47,1.08,3.26,1.51,1.11,11.77,1.09,1.04,4.16,2.94,1.07,1.15,7.41,3.84,
    1.05,1.32,10.34,1.29,2.11,1.04,4.07,1.62,1.06,18.47,1.13,1.07,5.59,3.17,1.05,1.26,8.92,1.03,1.18,12.33,
    1.21,1.09,4.67,2.61,1.06,1.03,6.44,1.88,1.05,1.17,14.85,1.04,2.36,1.06,3.77,1.58,1.07,16.23,1.31,1.03,
    7.29,2.41,1.09,1.12,5.42,3.98,1.07,1.23,9.14,1.05,1.04,11.81,1.32,1.14,4.84,2.33,1.06,1.03,7.62,4.91,
    1.08,1.17,12.47,1.03,3.72,1.26,2.05,1.04,1.14,25.93,1.36,1.07,4.53,3.64,1.05,1.12,6.21,1.09,1.04,8.71,
    1.26,1.05,5.32,2.47,1.07,1.11,14.31,1.03,1.07,10.57,1.19,1.14,4.91,3.53,1.04,1.26,9.07,1.03,1.18,13.24,
    1.39,1.06,4.62,2.83,1.07,1.03,6.97,1.92,1.05,1.21,18.61,1.06,3.22,1.15,2.41,1.05,1.08,11.39,1.12,1.03,
    8.51,1.28,1.04,4.17,3.11,1.06,1.18,7.73,1.04,1.29
  ];
  const TOTAL = MULTIPLIERS.length; // 250

  // ********** STORAGE HELPERS **********
  const key_accounts = 'avi_accounts';
  const key_session = 'avi_session';
  const key_past = 'avi_past';

  function loadAccounts(){ try { return JSON.parse(localStorage.getItem(key_accounts) || '{}') } catch(e){return {}}}
  function saveAccounts(obj){ localStorage.setItem(key_accounts, JSON.stringify(obj)) }
  function setSession(phone){ localStorage.setItem(key_session, phone) }
  function clearSession(){ localStorage.removeItem(key_session) }
  function getSession(){ return localStorage.getItem(key_session) }
  function loadPast(){ try { return JSON.parse(localStorage.getItem(key_past) || '[]') } catch(e){return []}}
  function savePast(arr){ localStorage.setItem(key_past, JSON.stringify(arr.slice(0,100))) }

  // ********** DOM **********
  const app = document.getElementById('app');
  const loading = document.getElementById('loading');
  const loginBtn = document.getElementById('loginBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const authOverlay = document.getElementById('authOverlay');
  const authTitle = document.getElementById('authTitle');
  const loginForm = document.getElementById('loginForm');
  const registerForm = document.getElementById('registerForm');
  const showRegister = document.getElementById('showRegister');
  const showLogin = document.getElementById('showLogin');
  const doLogin = document.getElementById('doLogin');
  const doRegister = document.getElementById('doRegister');
  const closeAuth = document.getElementById('closeAuth');
  const sessionName = document.getElementById('sessionName');
  const userNameTxt = document.getElementById('userNameTxt');
  const balanceBox = document.getElementById('balanceBox');
  const stakeInput = document.getElementById('stakeInput');
  const betButton = document.getElementById('betButton');
  const betAmount = document.getElementById('betAmount');
  const statusBox = document.getElementById('statusBox');
  const genIndex = document.getElementById('genIndex');
  const liveMultiplierEl = document.getElementById('liveMultiplier');
  const roundTimer = document.getElementById('roundTimer');
  const pastList = document.getElementById('pastList');
  const withdrawBtn = document.getElementById('withdrawBtn');
  const depositBtn = document.getElementById('depositBtn');
  const maxBtn = document.getElementById('maxBtn');
  const plus10 = document.getElementById('plus10');
  const plus50 = document.getElementById('plus50');
  const roundStateMsg = document.getElementById('roundStateMsg');
  const planeCanvas = document.getElementById('planeCanvas');
  const countdownBox = document.getElementById('countdownBox'); // Added for the hide/show logic

  // auth fields
  const loginPhone = document.getElementById('loginPhone');
  const loginPass = document.getElementById('loginPass');
  const regName = document.getElementById('regName');
  const regPhone = document.getElementById('regPhone');
  const regPass = document.getElementById('regPass');
  const regPass2 = document.getElementById('regPass2');
  const showRegisterLink = showRegister;
  const showLoginLink = showLogin;

  // ********** APP STATE **********
  let accounts = loadAccounts();
  let past = loadPast(); // last multipliers
  let currentUser = getSession(); // phone or null
  let userObj = currentUser ? accounts[currentUser] : null;

  // bets:
  let queuedBet = null;
  let activeBet = null;

  // NEW STATE VARIABLE for instantaneous round end
  let isRoundBurst = false; 

  function resizeCanvas(){
    // REMOVED PLANE ANIMATION: Removed canvas resize logic
  }
  window.addEventListener('resize', resizeCanvas);

  // ********** UTIL **********
  function now(){ return Date.now() }
  function formatNumber(n){ return Number(n).toFixed(2) }
  function safeNum(v){ return Math.max(0, Number(v) || 0) }

  function ensureAccount(phone){
    accounts = loadAccounts();
    if(!accounts[phone]){
      accounts[phone] = { name: phone, phone, pass: '', balance: DEFAULT_BALANCE };
      saveAccounts(accounts);
    }
    return accounts[phone];
  }

  // ********** ROUND / MULTIPLIER SCHEDULE **********
  
  function getRoundIndexForTime(t){
    // Let's revert the array indexing to the simpler fixed-cycle model for stability:
    const FIXED_CYCLE_FOR_INDEXING = PRE_ROUND + BASE_RATE_MS * 3; // Approx 10s base for array indexing
    const fixedCycleIndex = Math.floor(t / FIXED_CYCLE_FOR_INDEXING);
    const fixedRoundIndex = fixedCycleIndex % TOTAL;
    
    return fixedRoundIndex;
  }

  function getCurrentRoundInfo(){
    const t = now();
    const roundIndex = getRoundIndexForTime(t);
    const generated = MULTIPLIERS[roundIndex];
    
    // 1. Calculate the actual Flight Duration for this specific multiplier
    const flightTime = Math.log(generated || 1.01) * BASE_RATE_MS;
    // Cap flight time to a maximum reasonable value (e.g., 20 seconds for x250)
    const FLIGHT_ACTUAL = Math.min(20000, Math.max(100, flightTime)); 
    const CYCLE_ACTUAL = PRE_ROUND + FLIGHT_ACTUAL;

    // 2. Determine the current round's start time by relying on the FIXED_CYCLE_FOR_INDEXING
    const FIXED_CYCLE_FOR_INDEXING = PRE_ROUND + BASE_RATE_MS * 3;
    const cycleIndex = Math.floor(t / FIXED_CYCLE_FOR_INDEXING);
    const cycleStart = cycleIndex * FIXED_CYCLE_FOR_INDEXING;
    
    // Calculate actual elapsed time since the fixed start time
    const elapsed = t - cycleStart;
    
    // 3. Determine Phase and remaining time based on ACTUAL calculated cycle length
    let phase = 'ended'; 
    
    if (elapsed < PRE_ROUND) {
        phase = 'pre';
    } else if (elapsed < CYCLE_ACTUAL) {
        phase = 'flight';
    } else {
        phase = 'ended';
    }
    
    // NEW LOGIC: INSTANT ROUND END IF BURSTED
    // If we are currently in flight and the burst flag is set, transition phase to 'ended' immediately.
    if (phase === 'flight' && isRoundBurst) {
        phase = 'ended';
    }

    let phaseElapsed = 0;
    let phaseRemaining = 0;
    
    if (phase === 'pre') {
        phaseElapsed = elapsed;
        phaseRemaining = PRE_ROUND - elapsed;
    } else if (phase === 'flight') {
        phaseElapsed = elapsed - PRE_ROUND;
        phaseRemaining = FLIGHT_ACTUAL - phaseElapsed;
    } else {
        // If phase is 'ended' (either naturally or forced by burst)
        // We set the remaining time to 0, or calculate the time until the next fixed betting window starts
        phaseElapsed = FLIGHT_ACTUAL;
        // Calculate time until the next PRE_ROUND phase based on the fixed cycle time, NOT the actual variable cycle time.
        const nextCycleStart = (cycleIndex + 1) * FIXED_CYCLE_FOR_INDEXING;
        phaseRemaining = nextCycleStart - t;
    }

    return {
      roundIndex,
      generated,
      phase,
      phaseElapsed,
      phaseRemaining,
      elapsed,
      cycleStart,
      FLIGHT_ACTUAL
    };
  }

  // live multiplier value during flight: exponential based on constant rate
  function getLiveMultiplier(phase, phaseElapsed, generated, flightDuration){
    if(phase !== 'flight') return 1.00;
    const t = Math.max(0, Math.min(phaseElapsed, flightDuration));
    
    if (generated <= 1.0) return 1.00;
    
    // Formula: M(t) = e ^ (t / BASE_RATE_MS)
    const liveMult = Math.exp(t / BASE_RATE_MS);
    
    // Ensure the multiplier does not exceed the target value (generated)
    return Math.min(liveMult, generated);
  }

  // ********** PAST LIST **********
  function pushPast(mult){
    past.unshift(Number(mult));
    if(past.length>50) past.length=50;
    savePast(past);
    renderPast();
  }
  function renderPast(){
    pastList.innerHTML = '';
    for(let i=0;i<Math.min(10,past.length);i++){
      const v = past[i];
      const el = document.createElement('div');
      el.className='past-item';
      el.textContent = '×' + formatNumber(v);
      pastList.appendChild(el);
    }
  }

  // ********** UI / SESSION **********
  function refreshSession(){
    currentUser = getSession();
    userObj = currentUser ? (accounts[currentUser]) : null;
    if(userObj){
      sessionName.style.display='inline-block';
      userNameTxt.textContent = userObj.name || userObj.phone;
      loginBtn.style.display='none';
      logoutBtn.style.display='inline-block';
      balanceBox.textContent = String(userObj.balance);
    } else {
      sessionName.style.display='none';
      loginBtn.style.display='inline-block';
      logoutBtn.style.display='none';
      balanceBox.textContent = '1000';
    }
  }

  // ********** AUTH HANDLERS **********
  loginBtn.addEventListener('click', ()=>{ openAuth('login') });
  closeAuth.addEventListener('click', ()=>{ closeAuthOverlay() });
  logoutBtn.addEventListener('click', ()=>{
    clearSession();
    queuedBet = null; activeBet = null;
    statusBox.textContent = 'Logged out';
    refreshSession();
  });

  showRegisterLink.addEventListener('click', ()=>{ openAuth('register') });
  showLoginLink.addEventListener('click', ()=>{ openAuth('login') });

  function openAuth(mode='login'){
    authOverlay.style.display='flex';
    if(mode==='login'){
      authTitle.textContent='Login';
      loginForm.style.display='block';
      registerForm.style.display='none';
    } else {
      authTitle.textContent='Create account';
      loginForm.style.display='none';
      registerForm.style.display='block';
    }
  }
  function closeAuthOverlay(){
    authOverlay.style.display='none';
  }

  doRegister.addEventListener('click', ()=>{
    const name = regName.value.trim() || regPhone.value.trim();
    const phone = regPhone.value.trim();
    const p1 = regPass.value;
    const p2 = regPass2.value;
    if(!phone){ alert('Enter phone'); return; }
    if(!p1 || p1.length < 3){ alert('Password too short'); return; }
    if(p1 !== p2){ alert('Passwords do not match'); return; }
    accounts = loadAccounts();
    if(accounts[phone]){ alert('Account exists with this phone'); return; }
    accounts[phone] = { name, phone, pass: p1, balance: DEFAULT_BALANCE };
    saveAccounts(accounts);
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  doLogin.addEventListener('click', ()=>{
    const phone = loginPhone.value.trim();
    const pass = loginPass.value;
    if(!phone || !pass){ alert('Enter phone and password'); return; }
    accounts = loadAccounts();
    const acc = accounts[phone];
    if(!acc){ alert('No account found'); return; }
    if(acc.pass !== pass){ alert('Password incorrect'); return; }
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  // ********** BET / STAKE / BALANCE LOGIC **********
  function updateBetUI(){
    betAmount.textContent = (queuedBet ? queuedBet.amount : (activeBet? activeBet.amount : 0));
    const info = getCurrentRoundInfo();
    const liveMult = getLiveMultiplier(info.phase, info.phaseElapsed, info.generated, info.FLIGHT_ACTUAL); 
    const hasActiveBet = !!activeBet;

    // Determine if the round has burst or is over
    let shouldShowBetButton = false;
    
    if (hasActiveBet) {
      const isCurrentFlightBurst = (liveMult >= info.generated - 0.001);
      if (isCurrentFlightBurst || info.phase !== 'flight') {
        shouldShowBetButton = true; // Round ended or burst reached, show Bet button
      }
    } else if (queuedBet) {
      // Queued bet, show Cancel
      betButton.className = 'bet-button cancel';
      betButton.textContent = 'Cancel';
      return;
    }

    if(shouldShowBetButton){
      betButton.className = 'bet-button bet';
      betButton.textContent = 'Bet';
    } else if(hasActiveBet){
      // The bet is active and the plane is still flying below burst point.
      betButton.className = 'bet-button yellow';
      betButton.textContent = 'Cash out';
    } else {
      // Ready to bet
      betButton.className = 'bet-button bet';
      betButton.textContent = 'Bet';
    }
  }

  betButton.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const stake = safeNum(stakeInput.value);
    
    // Check the button's current mode (which is updated by updateBetUI)
    if(betButton.classList.contains('bet')){
      // Pressed Bet
      if(stake <= 0){ alert('Enter stake amount'); return; }
      if(stake > userObj.balance){ alert('Stake must be <= balance'); return; }
      queuedBet = { amount: stake };
      statusBox.textContent = 'Queued for next round. You may cancel before flight starts.';
      updateBetUI();
    } else if(betButton.classList.contains('cancel')){
      // cancel queued bet
      queuedBet = null;
      statusBox.textContent = 'Bet cancelled';
      updateBetUI();
    } else if(betButton.classList.contains('yellow')){
      // Cash out active bet
      if(!activeBet){ return; }
      
      const ri = activeBet.roundIndex;
      const generated = MULTIPLIERS[ri];
      const info = getCurrentRoundInfo();
      const live = getLiveMultiplier(info.phase, info.phaseElapsed, generated, info.FLIGHT_ACTUAL); 
      
      const win = activeBet.amount * live;
      accounts = loadAccounts();
      accounts[currentUser].balance = Number(accounts[currentUser].balance) + win;
      saveAccounts(accounts);
      userObj = accounts[currentUser];
      activeBet = null;
      statusBox.textContent = 'Cashed out: ×' + formatNumber(live) + ' → +' + formatNumber(win);
      balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
      updateBetUI();
    }
  });

  // utility to deduct stake from user at flight start
  function deductForActive(amt){
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) - amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
  }

  // ********** Main loop controlling rounds **********
  let lastRoundIndex = null;
  function mainTick(){
    const info = getCurrentRoundInfo();
    const idx = info.roundIndex;
    genIndex.textContent = idx + 1; // human 1..250

    // update past list rendering
    renderPast();
    
    const live = getLiveMultiplier(info.phase, info.phaseElapsed, info.generated, info.FLIGHT_ACTUAL);
    const isCurrentFlightBurst = (live >= info.generated - 0.001); // Check for burst with float safety

    // ************* NEW INSTANTANEOUS ROUND END LOGIC *************
    // This runs only while we are in the 'flight' phase
    if (info.phase === 'flight' && isCurrentFlightBurst) {
        // If burst detected, set flag and trigger the round end sequence next tick.
        // We set the flag here, and the getCurrentRoundInfo check will force the phase to 'ended' immediately.
        isRoundBurst = true;
        
        // Push the result instantly, as the round is effectively over.
        // Check if this round index hasn't been added to the past list yet (to prevent double-pushing)
        if (lastRoundIndex === idx) {
             const prevGen = MULTIPLIERS[lastRoundIndex];
             pushPast(prevGen);
             lastRoundIndex = null; // Mark as handled
             activeBet = null; // Clear active bet immediately upon burst
        }
        
    } else if (info.phase === 'pre') {
        // Reset the burst flag at the start of the betting window.
        isRoundBurst = false; 
    }
    // ************************************************************

    // phase transitions
    if(lastRoundIndex === null) lastRoundIndex = idx;

    // if a new round started (index changed, or forced reset by burst)
    if(idx !== lastRoundIndex && !isRoundBurst){ 
      // This block handles the natural transition when the fixed index moves.
      const prevGen = MULTIPLIERS[lastRoundIndex];
      pushPast(prevGen);
      activeBet = null; 
      // queued bets remain queued for next rounds (they will become active at flight start)
    }

    // UI Updates
    if(info.phase === 'pre'){
      roundStateMsg.textContent = 'Betting — Draw in'; 
      roundTimer.textContent = Math.ceil(info.phaseRemaining/1000) + 's';
      liveMultiplierEl.textContent = '×1.00';
      countdownBox.style.display = 'block'; 
    } else if (info.phase === 'flight') {
      countdownBox.style.display = 'none'; 
      roundStateMsg.textContent = 'Flight — live';
      // Display the actual flight time dynamically during flight 
      roundTimer.textContent = (info.FLIGHT_ACTUAL / 1000).toFixed(2) + 's'; 
      liveMultiplierEl.textContent = '×' + formatNumber(live);
    } else { // info.phase === 'ended' (either naturally or forced by burst/instant end)
      // This is the state where the Live Countdown ends instantly.
      countdownBox.style.display = 'block'; // Show countdown again
      roundStateMsg.textContent = 'Waiting — Next Round in'; // Indicate waiting time
      
      // Since we forced an end, we now show the remaining time until the next fixed 'pre' phase starts.
      // This remaining time IS the 5s pre-round countdown + any leftover time until the next index boundary.
      const remainingForNextPre = info.phaseRemaining; 
      roundTimer.textContent = Math.max(0, Math.ceil(remainingForNextPre/1000)) + 's';
      liveMultiplierEl.textContent = '×' + formatNumber(info.generated); // Display final value
    }

    // Now: if we are just going from PRE_ROUND to FLIGHT and there is queuedBet, make it active and deduct
    if(info.phase === 'flight'){
      if(queuedBet && !activeBet){
        // make it active for this round
        activeBet = { amount: queuedBet.amount, roundIndex: idx };
        queuedBet = null;
        // deduct immediately
        if(currentUser){
          deductForActive(activeBet.amount);
          statusBox.textContent = 'Bet active — good luck';
        } else {
          // if no user session, cancel
          activeBet = null;
          statusBox.textContent = 'No session — bet cancelled';
        }
      }
    }

    // Update bet UI
    updateBetUI();

    // update lastRoundIndex
    // Only update if not currently bursting, to ensure we process the burst logic correctly.
    if (!isRoundBurst) {
        lastRoundIndex = idx;
    }
  }

  // run mainTick every 120ms for responsiveness
  setInterval(mainTick, 120);

  // ********** UI actions **********
  withdrawBtn.addEventListener('click', ()=>{ alert('Withdrawal clicked (dummy). GitHub will log the click.'); });
  depositBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const amt = Number(prompt('Enter amount to deposit ():', '0')) || 0;
    if(amt===0) return;
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) + amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
    statusBox.textContent = 'Deposited ' + amt;
  });

  maxBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    accounts = loadAccounts();
    const bal = accounts[currentUser].balance || DEFAULT_BALANCE;
    stakeInput.value = bal;
  });
  plus10.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 10; });
  plus50.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 50; });

  // update displayed bet amount when stake changes
  stakeInput.addEventListener('input', ()=>{ betAmount.textContent = queuedBet ? queuedBet.amount : (activeBet? activeBet.amount : safeNum(stakeInput.value)); });

  // ********** initialization **********
  function init(){
    accounts = loadAccounts();
    past = loadPast();
    refreshSession();
    renderPast();
    loading.style.display='none';
    app.style.display='flex';
    // set initial UI
    updateBetUI();
  }
  init();

  // To mimic "ask to log in again if visit other apps" we clear session on visibilitychange when hidden (user leaves tab/app)
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      // clear session to force login on return
      clearSession();
      refreshSession();
      statusBox.textContent = 'Session cleared while away; please login again.';
    }
  });

  // persist past 10 on start (if empty fill with first few)
  if(!past || past.length===0){
    // fill with first 6 multipliers for display
    for(let i=0;i<6;i++) pushPast(MULTIPLIERS[(TOTAL - 1 - i + TOTAL) % TOTAL]);
  }

  // quick safety: keep UI updated if account changes
  window.setInterval(()=>{ accounts = loadAccounts(); if(currentUser) { userObj = accounts[currentUser]; if(userObj) balanceBox.textContent = String(Math.round(userObj.balance*100)/100); } }, 2000);

  // expose small debug on console
  console.log('Aviator demo initialized. Rounds every ' + (PRE_ROUND/1000) + 's betting phase. Flight time is now variable based on multiplier: FLIGHT = ln(M) * ' + BASE_RATE_MS + 'ms.');

})();
</script>
</body>
  </html>
