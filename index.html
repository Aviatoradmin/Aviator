<script>
/*
  Aviator single-file implementation
  ... (Rest of the script code remains the same) ...
*/

(() => {
  // ********** CONFIG **********
  const PRE_ROUND = 5_000;   // ms (betting countdown)
  const FLIGHT = 5_000;      // ms (flight duration)
  const CYCLE = PRE_ROUND + FLIGHT; // 10s
  const DEFAULT_BALANCE = 1000;
  const MULTIPLIERS = [
    1.27,2.14,1.03,3.82,7.41,1.56,1.11,4.27,12.49,1.24,2.71,1.09,8.35,1.63,1.02,5.42,2.03,1.18,3.54,10.83,
    1.15,1.07,6.48,2.32,1.95,1.04,1.34,9.64,1.13,3.09,1.26,4.91,2.67,1.08,1.52,1.21,14.72,1.03,2.18,1.09,
    1.88,3.47,1.06,7.22,1.24,1.11,2.97,5.84,1.04,18.93,1.27,1.18,4.48,1.06,2.54,1.77,8.92,1.39,1.08,3.63,
    1.14,1.04,22.41,1.57,2.01,1.07,4.12,6.83,1.09,1.28,3.96,2.38,1.05,1.16,15.74,1.23,1.02,9.83,2.91,1.31,
    1.18,4.34,1.47,1.06,13.56,1.09,2.26,1.04,6.37,3.04,1.07,1.12,5.78,2.79,1.03,1.61,12.84,1.05,4.53,1.07,
    1.32,6.92,1.14,1.03,24.61,1.19,2.47,1.08,3.26,1.51,1.11,11.77,1.09,1.04,4.16,2.94,1.07,1.15,7.41,3.84,
    1.05,1.32,10.34,1.29,2.11,1.04,4.07,1.62,1.06,18.47,1.13,1.07,5.59,3.17,1.05,1.26,8.92,1.03,1.18,12.33,
    1.21,1.09,4.67,2.61,1.06,1.03,6.44,1.88,1.05,1.17,14.85,1.04,2.36,1.06,3.77,1.58,1.07,16.23,1.31,1.03,
    7.29,2.41,1.09,1.12,5.42,3.98,1.07,1.23,9.14,1.05,1.04,11.81,1.32,1.14,4.84,2.33,1.06,1.03,7.62,4.91,
    1.08,1.17,12.47,1.03,3.72,1.26,2.05,1.04,1.14,25.93,1.36,1.07,4.53,3.64,1.05,1.12,6.21,1.09,1.04,8.71,
    1.26,1.05,5.32,2.47,1.07,1.11,14.31,1.03,1.07,10.57,1.19,1.14,4.91,3.53,1.04,1.26,9.07,1.03,1.18,13.24,
    1.39,1.06,4.62,2.83,1.07,1.03,6.97,1.92,1.05,1.21,18.61,1.06,3.22,1.15,2.41,1.05,1.08,11.39,1.12,1.03,
    8.51,1.28,1.04,4.17,3.11,1.06,1.18,7.73,1.04,1.29
  ];
  const TOTAL = MULTIPLIERS.length; // 250

  // ********** STORAGE HELPERS **********
  const key_accounts = 'avi_accounts';
  const key_session = 'avi_session';
  const key_past = 'avi_past';

  function loadAccounts(){ try { return JSON.parse(localStorage.getItem(key_accounts) || '{}') } catch(e){return {}}}
  function saveAccounts(obj){ localStorage.setItem(key_accounts, JSON.stringify(obj)) }
  function setSession(phone){ localStorage.setItem(key_session, phone) }
  function clearSession(){ localStorage.removeItem(key_session) }
  function getSession(){ return localStorage.getItem(key_session) }
  function loadPast(){ try { return JSON.parse(localStorage.getItem(key_past) || '[]') } catch(e){return []}}
  function savePast(arr){ localStorage.setItem(key_past, JSON.stringify(arr.slice(0,100))) }

  // ********** DOM **********
  const app = document.getElementById('app');
  const loading = document.getElementById('loading');
  const loginBtn = document.getElementById('loginBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const authOverlay = document.getElementById('authOverlay');
  const authTitle = document.getElementById('authTitle');
  const loginForm = document.getElementById('loginForm');
  const registerForm = document.getElementById('registerForm');
  const showRegister = document.getElementById('showRegister');
  const showLogin = document.getElementById('showLogin');
  const doLogin = document.getElementById('doLogin');
  const doRegister = document.getElementById('doRegister');
  const closeAuth = document.getElementById('closeAuth');
  const sessionName = document.getElementById('sessionName');
  const userNameTxt = document.getElementById('userNameTxt');
  const balanceBox = document.getElementById('balanceBox');
  const stakeInput = document.getElementById('stakeInput');
  const betButton = document.getElementById('betButton');
  const betAmount = document.getElementById('betAmount');
  const statusBox = document.getElementById('statusBox');
  const genIndex = document.getElementById('genIndex');
  const liveMultiplierEl = document.getElementById('liveMultiplier');
  const roundTimer = document.getElementById('roundTimer');
  const pastList = document.getElementById('pastList');
  const withdrawBtn = document.getElementById('withdrawBtn');
  const depositBtn = document.getElementById('depositBtn');
  const maxBtn = document.getElementById('maxBtn');
  const plus10 = document.getElementById('plus10');
  const plus50 = document.getElementById('plus50');
  const roundStateMsg = document.getElementById('roundStateMsg');
  const planeCanvas = document.getElementById('planeCanvas');

  // auth fields
  const loginPhone = document.getElementById('loginPhone');
  const loginPass = document.getElementById('loginPass');
  const regName = document.getElementById('regName');
  const regPhone = document.getElementById('regPhone');
  const regPass = document.getElementById('regPass');
  const regPass2 = document.getElementById('regPass2');
  const showRegisterLink = showRegister;
  const showLoginLink = showLogin;

  // ********** APP STATE **********
  let accounts = loadAccounts();
  let past = loadPast(); // last multipliers
  let currentUser = getSession(); // phone or null
  let userObj = currentUser ? accounts[currentUser] : null;

  // bets:
  // queuedBet: user has pressed Bet while NOT in-flight (i.e., during PRE_ROUND or during flight to join next), and can cancel before flight start
  // activeBet: {amount, roundIndex} when the flight starts, stake is deducted and becomes active; cashout allowed during flight
  let queuedBet = null;
  let activeBet = null;

  // canvas init
  const ctx = planeCanvas.getContext ? planeCanvas.getContext('2d') : null;
  let planeImg = new Image();
  // Changed image to a red plane (planeB.png) if planeA is not red
  // Assuming the user has a red plane icon, if not, the fallback triangle will be red.
  planeImg.src = 'planeA.png'; 
  planeImg.onerror = ()=>{ planeImg = null; } // fallback to drawing triangle

  function resizeCanvas(){
    planeCanvas.width = planeCanvas.clientWidth * devicePixelRatio;
    planeCanvas.height = planeCanvas.clientHeight * devicePixelRatio;
    ctx && ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resizeCanvas);

  // ********** UTIL **********
  function now(){ return Date.now() }
  function formatNumber(n){ return Number(n).toFixed(2) }
  function safeNum(v){ return Math.max(0, Number(v) || 0) }

  function ensureAccount(phone){
    accounts = loadAccounts();
    if(!accounts[phone]){
      accounts[phone] = { name: phone, phone, pass: '', balance: DEFAULT_BALANCE };
      saveAccounts(accounts);
    }
    return accounts[phone];
  }

  // ********** ROUND / MULTIPLIER SCHEDULE **********
  // We use fixed length cycles of CYCLE ms. Round index = floor(now / CYCLE) % TOTAL
  // Pre-round: [0, PRE_ROUND) => betting allowed, queued bets possible
  // Flight: [PRE_ROUND, CYCLE) => live multiplier increases from 1 to generatedMultiplier

  function getRoundIndexForTime(t){
    const idx = Math.floor(t / CYCLE) % TOTAL;
    return idx;
  }
  function getRoundStartTimeForIndex(i){
    // find the first time (>=0 epoch) where floor(t/CYCLE) % TOTAL == i
    // easiest: compute cycles since epoch and adjust
    const cyclesSinceEpoch = Math.floor(Date.now() / CYCLE);
    // compute currentIndex and difference
    const currentIndex = cyclesSinceEpoch % TOTAL;
    const diff = (i - currentIndex + TOTAL) % TOTAL;
    return (cyclesSinceEpoch + diff) * CYCLE;
  }

  function getCurrentRoundInfo(){
    const t = now();
    const cycleIndex = Math.floor(t / CYCLE);
    const roundIndex = cycleIndex % TOTAL;
    const cycleStart = cycleIndex * CYCLE;
    const elapsed = t - cycleStart;
    const phase = (elapsed < PRE_ROUND) ? 'pre' : 'flight';
    const phaseElapsed = (phase === 'pre') ? elapsed : (elapsed - PRE_ROUND);
    const phaseRemaining = (phase === 'pre') ? (PRE_ROUND - elapsed) : (CYCLE - elapsed);
    const generated = MULTIPLIERS[roundIndex];
    return {
      roundIndex,
      generated,
      phase,
      phaseElapsed,
      phaseRemaining,
      elapsed,
      cycleStart
    };
  }

  // live multiplier value during flight: linear from 1 -> generated over FLIGHT ms
  function getLiveMultiplier(phase, phaseElapsed, generated){
    if(phase !== 'flight') return 1.00;
    const t = Math.max(0, Math.min(phaseElapsed, FLIGHT));
    const ratio = t / FLIGHT;
    return 1 + (generated - 1) * ratio;
  }

  // ********** PAST LIST **********
  function pushPast(mult){
    past.unshift(Number(mult));
    if(past.length>50) past.length=50;
    savePast(past);
    renderPast();
  }
  function renderPast(){
    pastList.innerHTML = '';
    for(let i=0;i<Math.min(10,past.length);i++){
      const v = past[i];
      const el = document.createElement('div');
      el.className='past-item';
      el.textContent = '×' + formatNumber(v);
      pastList.appendChild(el);
    }
  }

  // ********** UI / SESSION **********
  function refreshSession(){
    currentUser = getSession();
    userObj = currentUser ? (accounts[currentUser]) : null;
    if(userObj){
      sessionName.style.display='inline-block';
      userNameTxt.textContent = userObj.name || userObj.phone;
      loginBtn.style.display='none';
      logoutBtn.style.display='inline-block';
      balanceBox.textContent = String(userObj.balance);
    } else {
      sessionName.style.display='none';
      loginBtn.style.display='inline-block';
      logoutBtn.style.display='none';
      balanceBox.textContent = '1000';
    }
  }

  // ********** AUTH HANDLERS **********
  loginBtn.addEventListener('click', ()=>{ openAuth('login') });
  closeAuth.addEventListener('click', ()=>{ closeAuthOverlay() });
  logoutBtn.addEventListener('click', ()=>{
    clearSession();
    queuedBet = null; activeBet = null;
    statusBox.textContent = 'Logged out';
    refreshSession();
  });

  showRegisterLink.addEventListener('click', ()=>{ openAuth('register') });
  showLoginLink.addEventListener('click', ()=>{ openAuth('login') });

  function openAuth(mode='login'){
    authOverlay.style.display='flex';
    if(mode==='login'){
      authTitle.textContent='Login';
      loginForm.style.display='block';
      registerForm.style.display='none';
    } else {
      authTitle.textContent='Create account';
      loginForm.style.display='none';
      registerForm.style.display='block';
    }
  }
  function closeAuthOverlay(){
    authOverlay.style.display='none';
  }

  doRegister.addEventListener('click', ()=>{
    const name = regName.value.trim() || regPhone.value.trim();
    const phone = regPhone.value.trim();
    const p1 = regPass.value;
    const p2 = regPass2.value;
    if(!phone){ alert('Enter phone'); return; }
    if(!p1 || p1.length < 3){ alert('Password too short'); return; }
    if(p1 !== p2){ alert('Passwords do not match'); return; }
    accounts = loadAccounts();
    if(accounts[phone]){ alert('Account exists with this phone'); return; }
    accounts[phone] = { name, phone, pass: p1, balance: DEFAULT_BALANCE };
    saveAccounts(accounts);
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  doLogin.addEventListener('click', ()=>{
    const phone = loginPhone.value.trim();
    const pass = loginPass.value;
    if(!phone || !pass){ alert('Enter phone and password'); return; }
    accounts = loadAccounts();
    const acc = accounts[phone];
    if(!acc){ alert('No account found'); return; }
    if(acc.pass !== pass){ alert('Password incorrect'); return; }
    setSession(phone);
    closeAuthOverlay();
    refreshSession();
  });

  // ********** BET / STAKE / BALANCE LOGIC **********
  function updateBetUI(){
    betAmount.textContent = (queuedBet ? queuedBet.amount : (activeBet? activeBet.amount : 0));
    // adjust button state
    if(activeBet){
      betButton.className = 'bet-button yellow';
      betButton.textContent = 'Cash out';
    } else if(queuedBet){
      betButton.className = 'bet-button cancel';
      betButton.textContent = 'Cancel';
    } else {
      betButton.className = 'bet-button bet';
      betButton.textContent = 'Bet';
    }
  }

  betButton.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const stake = safeNum(stakeInput.value);
    if(betButton.classList.contains('bet')){
      // Pressed Bet — this should queue the bet for next round or join next round depending on timing
      if(stake <= 0){ alert('Enter stake amount'); return; }
      if(stake > userObj.balance){ alert('Stake must be <= balance'); return; }
      queuedBet = { amount: stake };
      statusBox.textContent = 'Queued for next round. You may cancel before flight starts.';
      updateBetUI();
    } else if(betButton.classList.contains('cancel')){
      // cancel queued bet
      queuedBet = null;
      statusBox.textContent = 'Bet cancelled';
      updateBetUI();
    } else if(betButton.classList.contains('yellow')){
      // Cash out active bet
      if(!activeBet){ return; }
      // compute current live multiplier
      const ri = activeBet.roundIndex;
      const generated = MULTIPLIERS[ri];
      const info = getCurrentRoundInfo();
      const live = getLiveMultiplier(info.phase, info.phaseElapsed, generated);
      const win = activeBet.amount * live;
      accounts = loadAccounts();
      accounts[currentUser].balance = Number(accounts[currentUser].balance) + win;
      saveAccounts(accounts);
      userObj = accounts[currentUser];
      activeBet = null;
      statusBox.textContent = 'Cashed out: ×' + formatNumber(live) + ' → +' + formatNumber(win);
      balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
      updateBetUI();
    }
  });

  // utility to deduct stake from user at flight start
  function deductForActive(amt){
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) - amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
  }

  // if activeBet loses (burst), nothing to add (stake was already deducted)
  // ********** Main loop controlling rounds **********
  let lastRoundIndex = null;
  function mainTick(){
    const info = getCurrentRoundInfo();
    const idx = info.roundIndex;
    genIndex.textContent = idx + 1; // human 1..250

    // update past list rendering
    renderPast();

    // update phase text / timer
    if(info.phase === 'pre'){
      roundStateMsg.textContent = 'Betting — place stake';
      roundTimer.textContent = Math.ceil(info.phaseRemaining/1000) + 's';
      liveMultiplierEl.textContent = '×1.00';
      // if there is a queued bet and the current cycle transitions into flight, we will handle
    } else {
      roundStateMsg.textContent = 'Flight — live';
      roundTimer.textContent = Math.ceil(info.phaseRemaining/1000) + 's';
      const live = getLiveMultiplier(info.phase, info.phaseElapsed, info.generated);
      liveMultiplierEl.textContent = '×' + formatNumber(live);
    }

    // phase transitions
    if(lastRoundIndex === null) lastRoundIndex = idx;

    // if a new round started (index changed), then handle end-of-previous-round logic
    if(idx !== lastRoundIndex){
      // previous round ended -> its generated multiplier is MULTIPLIERS[lastRoundIndex]
      const prevGen = MULTIPLIERS[lastRoundIndex];
      pushPast(prevGen);
      // If there was an activeBet for prev round that wasn't cashed out, it's already deducted and lost (we do nothing)
      activeBet = null;
      // queued bets remain queued for next rounds (they will become active at flight start)
    }

    // If this is a new round and we are in PRE_ROUND now, nothing else
    // Now: if we are just going from PRE_ROUND to FLIGHT and there is queuedBet, make it active and deduct
    // We can detect the exact moment when phaseElapsed crosses PRE_ROUND
    // We'll detect when phase is 'flight' and we have queuedBet -> make active if not already active
    if(info.phase === 'flight'){
      if(queuedBet && !activeBet){
        // make it active for this round
        activeBet = { amount: queuedBet.amount, roundIndex: idx };
        queuedBet = null;
        // deduct immediately
        if(currentUser){
          deductForActive(activeBet.amount);
          statusBox.textContent = 'Bet active — good luck';
        } else {
          // if no user session, cancel
          activeBet = null;
          statusBox.textContent = 'No session — bet cancelled';
        }
      }
    }

    // if flight is active for this round and activeBet exists and was not cashed yet, cashout possible.
    // If flight ended this tick (i.e., near end), then settle losing bets: handled when nextIndex != lastRoundIndex earlier

    // Update bet UI
    updateBetUI();

    // update lastRoundIndex
    lastRoundIndex = idx;
  }

  // run mainTick every 120ms for responsiveness
  setInterval(mainTick, 120);

  // ********** Canvas: plane animation **********
  function drawPlane(progress, generated, burst){
    // progress: 0..1 across flight (if not in flight, provide idle progress)
    const w = planeCanvas.clientWidth;
    const h = planeCanvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    // background grid lightly
    // Draw a faint horizon
    ctx.fillStyle = '#071018';
    ctx.fillRect(0,0,w,h);

    const margin = 40;
    const width = w - margin*2;
    const height = h - margin*2;

    const PEAK_T = 0.5; // T value where the plane reaches max height (50% of travel time)
    const MAX_HEIGHT_NORM = 1; // Normalized max height (1 is top of canvas)
    const OSCILLATION_DURATION_T = 1 - PEAK_T; // Duration of oscillation phase in normalized time
    const OSCILLATION_MAX_AMPLITUDE_NORM = 0.1; // Max oscillation amplitude (10% of canvas height)

    let t = Math.max(0, Math.min(progress,1));
    let x, y, yNorm;

    // --- Part 1: Trajectory (0 to PEAK_T)
    if (t <= PEAK_T) {
      // Parabolic path (decay hanging graph-like, but inverted for lift-off)
      // Path will go from (0, height) to (PEAK_T*width, 0) in normalized space
      // Let's use a function that gives a steep climb and then levels off for max height.
      // Example: A cosine or parabolic segment. Using a parabola for simple trajectory:
      // A(t - PEAK_T)^2 + B
      yNorm = MAX_HEIGHT_NORM - (MAX_HEIGHT_NORM / PEAK_T**2) * (t - PEAK_T)**2;
      yNorm = Math.max(0, yNorm); // Ensure it doesn't go below the bottom boundary
    } 
    // --- Part 2: Oscillation/Decay (PEAK_T to 1.0)
    else {
      // Time relative to the start of the oscillation phase
      const tOsc = (t - PEAK_T) / OSCILLATION_DURATION_T; // 0 to 1

      // Higher multiplier gives longer oscillation time (which is the whole duration, FLIGHT)
      // We adjust the burst point based on the multiplier.
      // Burst time is defined by the multiplier (short multiplier -> short burst time, meaning it bursts earlier in this phase)
      // The multiplier is mapped to a burst time:
      // Minimum burst point: 0.1 (for 1.0 multiplier)
      // Maximum burst point: 0.95 (for 25.93 multiplier)
      const MIN_MULT = 1.01;
      const MAX_MULT = 25.93;
      const MIN_BURST_T = 0.01;
      const MAX_BURST_T = 0.95;
      
      let burstPointNorm;
      if (generated <= MIN_MULT) {
          burstPointNorm = MIN_BURST_T; // Bursts right away
      } else {
          // Normalize generated multiplier from [MIN_MULT, MAX_MULT] to [0, 1]
          const normMult = (generated - MIN_MULT) / (MAX_MULT - MIN_MULT);
          burstPointNorm = MIN_BURST_T + normMult * (MAX_BURST_T - MIN_BURST_T);
      }
      
      // If tOsc exceeds the burst point, freeze at max height and stop oscillating
      if (tOsc >= burstPointNorm) {
          yNorm = MAX_HEIGHT_NORM; // Stop oscillating, stay at max height
          tOsc = burstPointNorm; // Effectively cap time for oscillation
      } else {
        // Oscillation motion: decay hanging graph mimic, oscillating up/down (>)<)
        // Cosine wave for oscillation: * (tOsc * 2*PI * frequency)
        // Exponential decay for amplitude: Math.exp(-decayRate * tOsc)
        const frequency = 4; // Cycles in this phase
        const decayRate = 1.5;
        const amplitude = OSCILLATION_MAX_AMPLITUDE_NORM * Math.exp(-decayRate * tOsc);
        const oscillation = amplitude * Math.cos(tOsc * 2 * Math.PI * frequency);

        // Y-coordinate starts at max height (1) and oscillates around it.
        yNorm = MAX_HEIGHT_NORM + oscillation;
      }
    }

    // X-coordinate is still linear from left to right (0 to width)
    x = margin + t * width;

    // Convert normalized y (0=top, 1=bottom) to canvas y (margin=top, h-margin=bottom)
    y = margin + (1 - yNorm) * height;


    // --- Path Drawing (Simplified for the new non-standard path) ---
    // Draw only a straight line from start to current plane position to mimic the rope
    ctx.beginPath();
    // Start at original y=0, x=0 (plane box corner, i.e., margin, h-margin)
    const ropeStartX = margin;
    const ropeStartY = h - margin; // Corrected to be bottom corner (y=0 in un-normalized space)
    
    // Draw the "Red Rope" holding the plane to the original y=0 x=0 corner
    ctx.moveTo(ropeStartX, ropeStartY);
    ctx.lineTo(x, y); // Line to current plane position
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'var(--red)'; // Use the CSS variable for red
    ctx.stroke();


    // --- Plane Drawing ---
    const planeW = 46;
    const planeH = 28;
    ctx.save();
    ctx.translate(x, y);
    
    // Rotation logic (simplified or disabled for the custom rope/oscillation)
    // To preserve the motion from the original code (parabolic trajectory):
    const dx = 8;
    const tAhead = Math.min(1, t + 0.02);
    // Recalculate y2 based on the new logic
    let yNorm2, y2;
    if (tAhead <= PEAK_T) {
        yNorm2 = MAX_HEIGHT_NORM - (MAX_HEIGHT_NORM / PEAK_T**2) * (tAhead - PEAK_T)**2;
        yNorm2 = Math.max(0, yNorm2);
    } else {
        // For simplicity during oscillation, we can assume a slight fixed angle or calculate a small tangent
        const tOsc2 = (tAhead - PEAK_T) / OSCILLATION_DURATION_T;
        if (tOsc2 >= burstPointNorm) {
            yNorm2 = MAX_HEIGHT_NORM;
        } else {
            const frequency = 4;
            const decayRate = 1.5;
            const amplitude = OSCILLATION_MAX_AMPLITUDE_NORM * Math.exp(-decayRate * tOsc2);
            const oscillation = amplitude * Math.cos(tOsc2 * 2 * Math.PI * frequency);
            yNorm2 = MAX_HEIGHT_NORM + oscillation;
        }
    }
    y2 = margin + (1 - yNorm2) * height;

    const angle = Math.atan2(y2 - y, (margin + tAhead*width) - x); // Use x at tAhead for tangent
    ctx.rotate(angle);

    if(planeImg && planeImg.complete){
      ctx.drawImage(planeImg, -planeW/2, -planeH/2, planeW, planeH);
    } else {
      // fallback: small red triangle
      ctx.fillStyle = 'var(--red)'; // Ensure fallback is red
      ctx.beginPath();
      ctx.moveTo(0,-10);
      ctx.lineTo(16,0);
      ctx.lineTo(0,10);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // draw burst indicator if near end
    // Burst is determined by tOsc reaching burstPointNorm in the new logic
    const info = getCurrentRoundInfo();
    if(info.phase === 'flight'){
        const tOsc = (t - PEAK_T) / OSCILLATION_DURATION_T;
        if(tOsc >= burstPointNorm){
             burst = true;
        } else {
             burst = false;
        }
    }

    if(burst){
      ctx.fillStyle = 'rgba(240,200,0,0.06)';
      ctx.beginPath();
      ctx.arc(x, y, 60, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function animLoop(){
    const info = getCurrentRoundInfo();
    let progress = 0;
    let generated = MULTIPLIERS[info.roundIndex];
    let burst = false;
    if(info.phase === 'pre'){
      // idle motion: gentle oscillation
      const t = ((now()%2000)/2000);
      progress = 0.01 + 0.02*Math.sin(t*Math.PI*2); // near origin
    } else {
      const ratio = Math.max(0, Math.min(info.phaseElapsed / FLIGHT, 1));
      // we map ratio to progress with slight easing to look like plane accelerating upwards
      progress = Math.pow(ratio, 0.9);
      // Burst detection moved into drawPlane to use generated/burstPointNorm
    }
    drawPlane(progress, generated, burst);
    requestAnimationFrame(animLoop);
  }
  // start animations after first resize
  window.requestAnimationFrame(()=>{ resizeCanvas(); animLoop(); });

  // ********** periodic housekeeping: when flight ends, settle round and push past **********
  // We use mainTick and the past push logic already handles this.

  // ********** UI actions **********
  withdrawBtn.addEventListener('click', ()=>{ alert('Withdrawal clicked (dummy). GitHub will log the click.'); });
  depositBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    const amt = Number(prompt('Enter amount to deposit :', '100')) || 0;
    if(amt=0) return;
    accounts = loadAccounts();
    accounts[currentUser].balance = Number(accounts[currentUser].balance) + amt;
    saveAccounts(accounts);
    userObj = accounts[currentUser];
    balanceBox.textContent = String(Math.round(userObj.balance*100)/100);
    statusBox.textContent = 'Deposited ' + amt;
  });

  maxBtn.addEventListener('click', ()=>{
    if(!currentUser){ openAuth('login'); return; }
    accounts = loadAccounts();
    const bal = accounts[currentUser].balance || DEFAULT_BALANCE;
    stakeInput.value = bal;
  });
  plus10.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 10; });
  plus50.addEventListener('click', ()=>{ stakeInput.value = safeNum(stakeInput.value) + 50; });

  // update displayed bet amount when stake changes
  stakeInput.addEventListener('input', ()=>{ betAmount.textContent = queuedBet ? queuedBet.amount : (activeBet? activeBet.amount : safeNum(stakeInput.value)); });

  // ********** initialization **********
  function init(){
    accounts = loadAccounts();
    past = loadPast();
    refreshSession();
    renderPast();
    loading.style.display='none';
    app.style.display='flex';
    // set initial UI
    updateBetUI();
  }
  init();

  // onbeforeunload -> require login again if they close tab? User wants to re-login when visiting other apps.
  // We'll preserve session but require login if they explicitly log out. The user asked: "Ask to log in again if someone Log out Visit other apps Visit other links" — we can't detect app switching; but leaving page and returning keeps session. If they want always re-login we could clear session on visibilitychange hidden; but that would be annoying. We'll clear session on pagehide to match their note that visiting other apps should ask login.
  window.addEventListener('pagehide', ()=>{ /* intentionally do nothing to preserve session */ });
  // To mimic "ask to log in again if visit other apps" we clear session on visibilitychange when hidden (user leaves tab/app)
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      // clear session to force login on return
      // NOTE: this mirrors user's requirement to re-login when visiting other apps/links
      // BUT if you prefer persistent session, comment next line out.
      clearSession();
      refreshSession();
      statusBox.textContent = 'Session cleared while away; please login again.';
    }
  });

  // persist past 10 on start (if empty fill with first few)
  if(!past || past.length===0){
    // fill with first 6 multipliers for display
    for(let i=0;i<6;i++) pushPast(MULTIPLIERS[(TOTAL - 1 - i + TOTAL) % TOTAL]);
  }

  // quick safety: keep UI updated if account changes
  window.setInterval(()=>{ accounts = loadAccounts(); if(currentUser) { userObj = accounts[currentUser]; if(userObj) balanceBox.textContent = String(Math.round(userObj.balance*100)/100); } }, 2000);

  // expose small debug on console
  console.log('Aviator demo initialized. Rounds every ' + (CYCLE/1000) + 's. Total multipliers:', TOTAL);

})();
</script>
