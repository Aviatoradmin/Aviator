<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aviator - Mobile Game</title>
    <style>
        /* General Setup and Mobile-First Styling */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: black;
            color: white;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling */
        }

        /* --- A. Login/Account Area Styling --- */
        #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0000FF; /* Blue color for login page */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .login-box {
            background-color: #333;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 80%;
            max-width: 400px;
        }

        .login-box input {
            width: 90%;
            padding: 10px;
            margin-bottom: 15px;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .toggle-password {
            position: relative;
        }

        .toggle-password button {
            position: absolute;
            right: 5%;
            top: 10px;
            background: none;
            border: none;
            color: gray;
            cursor: pointer;
        }

        .login-box button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #auth-choice {
            margin-bottom: 20px;
        }

        #auth-choice button {
            background-color: #555;
            color: white;
            font-weight: bold;
        }

        /* --- B. Game Body (Aviator) Styling --- */
        #game-body {
            display: none; /* Hidden until login successful */
            flex-direction: column;
            flex-grow: 1;
        }

        /* Top Bar */
        #top-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            height: 10vh; /* ~10% of screen height */
        }

        .top-box {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            flex: 1;
            margin: 0 5px;
        }

        #withdraw-bar {
            background-color: yellow;
            color: black;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        #balance-bar {
            background-color: green;
            color: white;
        }

        /* Withdrawal Overlay in Top Bar */
        #withdraw-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: yellow;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #withdraw-content input {
            width: 80%;
            padding: 5px;
            margin-bottom: 5px;
        }

        #withdraw-content button {
            background-color: blue;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            font-weight: bold;
        }

        /* Past Multipliers Bar */
        #multiplier-bar {
            height: 5vh; /* ~5% of screen height */
            background-color: #222;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            padding: 0 5px;
            overflow: hidden;
            white-space: nowrap;
        }

        .past-multiplier {
            margin-right: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .low-mult { background-color: #880000; } /* Red for low values */
        .high-mult { background-color: #008800; } /* Green for high values */

        /* Aviator Plane Area */
        #plane-box {
            flex-grow: 1; /* Takes remaining space, approx 50% */
            min-height: 50vh;
            position: relative;
            overflow: hidden;
            border: 1px solid #333;
            background-color: #111;
        }

        #plane {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: red;
            border-radius: 50%; /* Representing the plane */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            left: 0;
            bottom: 0;
            transform: translate(0, 0); /* Start at bottom-left corner */
            transition: none; /* Will use JS for controlled movement */
        }
        
        #plane-box.busted #plane {
            background-color: #555;
            animation: burst-fade 0.5s ease-out;
        }
        
        @keyframes burst-fade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(3); }
        }

        /* Bottom Bar */
        #bottom-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            height: 20vh; /* ~20% of screen height */
        }

        #stake-box {
            background-color: #333;
            flex: 1;
            margin-right: 10px;
            padding: 10px;
            border-radius: 5px;
        }

        #stake-box input {
            width: 100%;
            padding: 10px 0;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            background: #444;
            color: white;
            margin-top: 5px;
            box-sizing: border-box;
        }

        #bet-bar {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .bet-default {
            background-color: green;
        }

        .bet-active {
            background-color: yellow;
            color: black;
        }

        .bet-waiting {
            background-color: red;
        }

        .bet-info {
            font-size: 0.8em;
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div id="login-overlay">
        <div class="login-box">
            <h2 id="auth-title">Welcome to Aviator</h2>
            <div id="auth-choice">
                <button id="btn-create-account">Create Account</button>
                <button id="btn-login">Log In</button>
            </div>
            
            <div id="create-section" style="display:none;">
                <input type="tel" id="create-phone" placeholder="Phone Number" value="0712345678">
                <div class="toggle-password">
                    <input type="password" id="create-password" placeholder="Password" value="password123">
                    <button type="button" class="password-toggle">üëÅÔ∏è</button>
                </div>
                <div class="toggle-password">
                    <input type="password" id="confirm-password" placeholder="Confirm Password" value="password123">
                    <button type="button" class="password-toggle">üëÅÔ∏è</button>
                </div>
                <button id="btn-submit-create">Create Account</button>
            </div>

            <div id="login-section" style="display:none;">
                <input type="tel" id="login-phone" placeholder="Phone Number" value="0712345678">
                <div class="toggle-password">
                    <input type="password" id="login-password" placeholder="Password" value="password123">
                    <button type="button" class="password-toggle">üëÅÔ∏è</button>
                </div>
                <button id="btn-submit-login">Log In</button>
            </div>
            <p style="font-size:0.8em;">(Simulated: You can save Password to browser)</p>
            <button id="btn-logout" style="display:none; background-color: #880000; color: white; margin-top: 15px;">Log Out</button>
        </div>
    </div>

    <div id="game-body">
        
        <div id="top-bar">
            <div id="withdraw-bar" class="top-box">
                WITHDRAW
                <div id="withdraw-content" style="display: none;">
                    <input type="number" id="withdraw-amount" placeholder="Amount">
                    <button id="btn-proceed-withdraw">Proceed</button>
                </div>
            </div>
            <div id="balance-bar" class="top-box">
                BALANCE: <span id="balance-display">1000</span>
            </div>
        </div>

        <div id="multiplier-bar">
            </div>

        <div id="plane-box">
            <div id="plane" style="display: none;">
                √ó1.00
            </div>
        </div>

        <div id="bottom-bar">
            <div id="stake-box">
                <label for="stake-amount">STAKE</label>
                <input type="number" id="stake-amount" value="10" min="1" oninput="updateBetAmount(this.value)">
            </div>
            
            <div id="bet-bar" class="bet-default">
                <span id="bet-action">BET</span>
                <span id="bet-amount" class="bet-info">10</span>
            </div>
        </div>

    </div>

    <script>
        // --- GLOBAL GAME STATE & VARIABLES ---
        const gameState = {
            balance: 1000,
            stake: 10,
            currentBet: 0,
            hasBet: false,
            isRoundActive: false,
            isWaitingForNextRound: false,
            generatedMultiplier: 0,
            liveMultiplier: 1.00,
            winnings: 0,
            pastMultipliers: [],
            loginData: JSON.parse(localStorage.getItem('aviatorUser')) || null
        };

        const elements = {
            loginOverlay: document.getElementById('login-overlay'),
            gameBody: document.getElementById('game-body'),
            balanceDisplay: document.getElementById('balance-display'),
            stakeInput: document.getElementById('stake-amount'),
            betBar: document.getElementById('bet-bar'),
            betAction: document.getElementById('bet-action'),
            betAmountDisplay: document.getElementById('bet-amount'),
            planeBox: document.getElementById('plane-box'),
            plane: document.getElementById('plane'),
            multiplierBar: document.getElementById('multiplier-bar'),
            withdrawBar: document.getElementById('withdraw-bar'),
            withdrawContent: document.getElementById('withdraw-content'),
            withdrawAmountInput: document.getElementById('withdraw-amount')
        };
        
        let planeAnimationInterval;
        let roundCountdownInterval;

        // --- A. LOGIN & ACCOUNT LOGIC ---

        function togglePasswordVisibility(button) {
            const input = button.previousElementSibling;
            if (input.type === "password") {
                input.type = "text";
                button.textContent = 'üôà';
            } else {
                input.type = "password";
                button.textContent = 'üëÅÔ∏è';
            }
        }

        document.querySelectorAll('.password-toggle').forEach(button => {
            button.addEventListener('click', () => togglePasswordVisibility(button));
        });
        
        document.getElementById('btn-create-account').addEventListener('click', () => {
            document.getElementById('auth-choice').style.display = 'none';
            document.getElementById('auth-title').textContent = 'Create Account';
            document.getElementById('create-section').style.display = 'block';
            document.getElementById('login-section').style.display = 'none';
        });

        document.getElementById('btn-login').addEventListener('click', () => {
            document.getElementById('auth-choice').style.display = 'none';
            document.getElementById('auth-title').textContent = 'Log In';
            document.getElementById('create-section').style.display = 'none';
            document.getElementById('login-section').style.display = 'block';
        });

        document.getElementById('btn-submit-create').addEventListener('click', () => {
            const phone = document.getElementById('create-phone').value;
            const password = document.getElementById('create-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;
            
            if (password !== confirmPassword) {
                alert("Passwords do not match!");
                return;
            }
            
            gameState.loginData = { phone, password };
            gameState.balance = 1000;
            localStorage.setItem('aviatorUser', JSON.stringify(gameState.loginData));
            alert('Account created! Default balance: 1000');
            loginSuccess();
        });

        document.getElementById('btn-submit-login').addEventListener('click', () => {
            const phone = document.getElementById('login-phone').value;
            const password = document.getElementById('login-password').value;

            if (!gameState.loginData) {
                alert('No account found. Please create one.');
                return;
            }

            if (phone === gameState.loginData.phone && password === gameState.loginData.password) {
                loginSuccess();
            } else {
                alert('Invalid phone number or password.');
            }
        });

        document.getElementById('btn-logout').addEventListener('click', () => {
            logout();
        });

        function loginSuccess() {
            elements.loginOverlay.style.display = 'none';
            elements.gameBody.style.display = 'flex';
            updateUI();
            // Start the cycle when logging in, as requested
            if (!gameState.isRoundActive && !gameState.isWaitingForNextRound) {
                startWaitingPeriod();
            }
        }

        function logout() {
            gameState.isRoundActive = false;
            gameState.isWaitingForNextRound = false;
            clearInterval(planeAnimationInterval);
            clearInterval(roundCountdownInterval);
            elements.loginOverlay.style.display = 'flex';
            elements.gameBody.style.display = 'none';
            document.getElementById('auth-choice').style.display = 'block';
            document.getElementById('create-section').style.display = 'none';
            document.getElementById('login-section').style.display = 'none';
            document.getElementById('auth-title').textContent = 'Welcome to Aviator';
        }

        // Check for existing login data on load and force login if data exists
        if (gameState.loginData) {
            document.getElementById('auth-choice').style.display = 'none';
            document.getElementById('auth-title').textContent = 'Log In';
            document.getElementById('login-section').style.display = 'block';
        }

        // --- B. GAME LOGIC & FUNCTIONS ---

        function updateUI() {
            elements.balanceDisplay.textContent = gameState.balance.toFixed(2);
            elements.betAmountDisplay.textContent = gameState.stake;
            elements.stakeInput.value = gameState.stake;
        }

        function updateBetAmount(value) {
            const amount = parseFloat(value);
            if (amount > 0 && amount <= gameState.balance) {
                gameState.stake = amount;
                elements.betAmountDisplay.textContent = amount;
            } else if (amount > gameState.balance) {
                alert("Stake cannot exceed balance!");
                elements.stakeInput.value = gameState.stake; // Revert
                elements.betAmountDisplay.textContent = gameState.stake;
            }
        }

        function generateMultiplier() {
            // Random multiplier between 1.01 and 10.00
            return (Math.random() * 8.99 + 1.01).toFixed(2);
        }

        function savePastMultiplier(multiplier) {
            gameState.pastMultipliers.unshift(multiplier);
            if (gameState.pastMultipliers.length > 10) {
                gameState.pastMultipliers.pop();
            }
            renderPastMultipliers();
        }

        function renderPastMultipliers() {
            elements.multiplierBar.innerHTML = gameState.pastMultipliers.map(mult => {
                const value = parseFloat(mult);
                const colorClass = value >= 2.00 ? 'high-mult' : 'low-mult';
                return `<span class="past-multiplier ${colorClass}">√ó${mult}</span>`;
            }).join('');
        }

        // --- BETTING & CASH OUT LOGIC ---

        elements.betBar.addEventListener('click', () => {
            if (elements.withdrawContent.style.display === 'flex') return; // Do nothing if withdraw is open

            if (gameState.hasBet) {
                // CASH OUT
                if (gameState.isRoundActive) {
                    cashOut();
                }
            } else {
                // BET / CANCEL
                const stake = parseFloat(elements.stakeInput.value);
                if (stake <= 0 || stake > gameState.balance) {
                    alert("Invalid stake amount or insufficient balance.");
                    return;
                }

                if (gameState.isWaitingForNextRound) {
                    // CANCEL from Waiting
                    if (elements.betAction.textContent === 'CANCEL') {
                        cancelBet();
                    } else {
                        // BET for Next Round (during 5s countdown)
                        placeBet(stake);
                        elements.betAction.textContent = 'CANCEL';
                        elements.betAmountDisplay.textContent = 'Waiting for next round';
                        elements.betBar.className = 'bet-waiting';
                    }
                } else if (gameState.isRoundActive) {
                    // BET for Next Round (during ongoing draw)
                    placeBet(stake);
                    elements.betAction.textContent = 'CANCEL';
                    elements.betAmountDisplay.textContent = 'Waiting for next round';
                    elements.betBar.className = 'bet-waiting';
                    gameState.isWaitingForNextRound = true; // Set waiting mode
                } else {
                    // BET at the start of waiting period
                    placeBet(stake);
                    elements.betAction.textContent = 'CANCEL';
                    elements.betAmountDisplay.textContent = 'Waiting for next round';
                    elements.betBar.className = 'bet-waiting';
                    gameState.isWaitingForNextRound = true; // Set waiting mode
                }
            }
        });
        
        function placeBet(amount) {
            gameState.currentBet = amount;
            gameState.hasBet = true;
            // Balance deduction is deferred until round starts for successful stake, but we track it.
            // For this simulation, we'll deduct when the round *starts* to honour the cancel logic.
            // If the user Cancels, the balance will be untouched.
        }

        function cancelBet() {
            gameState.hasBet = false;
            gameState.currentBet = 0;
            gameState.isWaitingForNextRound = false;
            // Restore UI to default Bet state
            elements.betAction.textContent = 'BET';
            elements.betAmountDisplay.textContent = gameState.stake;
            elements.betBar.className = 'bet-default';
            // Since balance was not deducted yet (it's for the *next* round), no addition is needed.
        }

        function cashOut() {
            const winnings = gameState.currentBet * gameState.liveMultiplier;
            gameState.balance += winnings;
            gameState.hasBet = false;
            gameState.currentBet = 0;
            updateUI();
            
            // Revert UI to default Bet state
            elements.betAction.textContent = 'BET';
            elements.betAmountDisplay.textContent = gameState.stake;
            elements.betBar.className = 'bet-default';
            elements.stakeInput.disabled = false;
            
            alert(`CASH OUT SUCCESSFUL at √ó${gameState.liveMultiplier.toFixed(2)}! Winnings: ${winnings.toFixed(2)}`);
        }
        
        function loseBet() {
            // Balance was already deducted at round start.
            gameState.hasBet = false;
            gameState.currentBet = 0;
            
            // Revert UI to default Bet state
            elements.betAction.textContent = 'BET';
            elements.betAmountDisplay.textContent = gameState.stake;
            elements.betBar.className = 'bet-default';
            elements.stakeInput.disabled = false;
            
            alert('BUSTED! You lost your stake.');
        }

        // --- ROUND CYCLE & ANIMATION ---

        function startWaitingPeriod() {
            gameState.isRoundActive = false;
            elements.plane.style.display = 'none';
            elements.planeBox.classList.remove('busted');
            clearInterval(planeAnimationInterval);
            
            let countdown = 5;
            elements.planeBox.innerHTML = `<h2 style="text-align:center; padding-top:20%;">Next round starts in ${countdown}s...</h2>`;

            roundCountdownInterval = setInterval(() => {
                countdown--;
                elements.planeBox.innerHTML = `<h2 style="text-align:center; padding-top:20%;">Next round starts in ${countdown}s...</h2>`;

                if (countdown <= 0) {
                    clearInterval(roundCountdownInterval);
                    startRound();
                }
            }, 1000);
        }

        function startRound() {
            gameState.isRoundActive = true;
            gameState.isWaitingForNextRound = false;
            gameState.liveMultiplier = 1.00;
            gameState.generatedMultiplier = generateMultiplier();
            elements.planeBox.innerHTML = '';
            elements.plane.style.display = 'flex';
            elements.plane.style.left = '0%';
            elements.plane.style.bottom = '0%';
            elements.plane.textContent = '√ó1.00';
            
            // Successful Stake Logic: Deduct balance now if user had bet
            if (gameState.hasBet) {
                gameState.balance -= gameState.currentBet;
                updateUI();
                elements.betAction.textContent = 'CASH OUT';
                elements.betBar.className = 'bet-active';
                elements.stakeInput.disabled = true;
            } else {
                elements.betAction.textContent = 'BET';
                elements.betBar.className = 'bet-default';
                elements.stakeInput.disabled = false;
            }

            planeAnimationInterval = setInterval(animatePlane, 100); // 100ms update rate
        }
        
        let startTime = Date.now();
        let pathProgress = 0; // 0 to 1

        function animatePlane() {
            const elapsed = (Date.now() - startTime) / 1000; // time in seconds
            const maxMultiplier = parseFloat(gameState.generatedMultiplier);
            
            // Multiplier calculation (simple exponential growth simulation)
            // m(t) = 1 + A * t^2. We'll use time as the multiplier, but accelerate it
            const currentMultiplier = 1 + 0.1 * elapsed * elapsed;
            gameState.liveMultiplier = Math.min(currentMultiplier, maxMultiplier);

            elements.plane.textContent = `√ó${gameState.liveMultiplier.toFixed(2)}`;
            
            if (gameState.liveMultiplier >= maxMultiplier) {
                // BURST EVENT
                clearInterval(planeAnimationInterval);
                gameState.isRoundActive = false;
                elements.planeBox.classList.add('busted');
                
                // If player failed to Cash Out, they lose the bet
                if (gameState.hasBet) {
                    loseBet();
                }
                
                savePastMultiplier(maxMultiplier);
                
                // Start the next waiting period after 3 seconds (to show burst)
                setTimeout(startWaitingPeriod, 3000);
                return;
            }
            
            // --- Plane Movement Logic ---
            const planeBoxRect = elements.planeBox.getBoundingClientRect();
            const boxW = planeBoxRect.width;
            const boxH = planeBoxRect.height;
            const maxDiagonalDistance = Math.sqrt(boxW * boxW + boxH * boxH);
            
            // Progress is based on the multiplier value
            let normalizedMult = Math.min(1, (gameState.liveMultiplier - 1.0) / (maxMultiplier - 1.0));
            
            let x, y;
            
            if (normalizedMult < 0.7) { 
                // Phase 1: Diagonal movement up to ~70% of max diagonal (3/4 of path)
                // x and y increase linearly with normalizedMult (for simplicity of simulation)
                // Plane starts at (0, 100% - planeH) to simulate bottom-left start
                const xProgress = normalizedMult / 0.7; // 0 to 1 over first 70%
                x = xProgress * boxW * 0.75; // Move up to 75% of box width
                y = boxH - (xProgress * boxH * 0.75); // Move from 100% height down to 25% height
                
            } else {
                // Phase 2: Up and Down wave motion
                const waveProgress = (normalizedMult - 0.7) / 0.3; // 0 to 1 over last 30%
                
                // Constant x position after 75% point
                x = boxW * 0.75;
                
                // Sinusoidal wave motion for y
                const waveAmplitude = boxH * 0.1; // 10% of box height for the wave
                const verticalOffset = boxH * 0.25; // Base height where wave starts
                
                // Smooth wave motion that increases speed towards burst
                // Use a combination of elapsed time and waveProgress
                const waveFactor = Math.sin(elapsed * 5) * waveAmplitude; 
                
                y = boxH - (verticalOffset + waveFactor);

                // Optional: For the requested 'increasing increment and reduction', the sin function's changing slope handles this naturally.
                // We'll keep it simple with sin(t) for a smooth curve.
            }
            
            // Update plane position (using bottom-left as reference for plane box)
            elements.plane.style.left = `${x}px`;
            elements.plane.style.bottom = `${boxH - y}px`;

            // Winnings update in real-time
            if (gameState.hasBet) {
                elements.betAmountDisplay.textContent = (gameState.currentBet * gameState.liveMultiplier).toFixed(2);
            }
        }
        
        // --- WITHDRAWAL LOGIC ---
        
        elements.withdrawBar.addEventListener('click', () => {
            if (gameState.isRoundActive) return; // Cannot withdraw during a round

            if (elements.withdrawContent.style.display === 'none') {
                elements.withdrawContent.style.display = 'flex';
                elements.withdrawBar.style.backgroundColor = 'white';
                elements.withdrawBar.style.color = 'black';
            } else {
                // Close on second click unless proceeding
                elements.withdrawContent.style.display = 'none';
                elements.withdrawBar.style.backgroundColor = 'yellow';
            }
        });
        
        document.getElementById('btn-proceed-withdraw').addEventListener('click', () => {
            const amount = parseFloat(elements.withdrawAmountInput.value);
            
            if (isNaN(amount) || amount <= 0 || amount > gameState.balance) {
                alert("Invalid amount or insufficient balance for withdrawal.");
                return;
            }

            gameState.balance -= amount;
            updateUI();
            
            // Show SUBMITTED message
            elements.withdrawContent.innerHTML = 'SUBMITTED';
            elements.withdrawBar.style.backgroundColor = 'green';
            
            // Reset after 3 seconds
            setTimeout(() => {
                elements.withdrawContent.style.display = 'none';
                elements.withdrawBar.style.backgroundColor = 'yellow';
                elements.withdrawBar.innerHTML = `WITHDRAW
                    <div id="withdraw-content" style="display: none;">
                        <input type="number" id="withdraw-amount" placeholder="Amount">
                        <button id="btn-proceed-withdraw">Proceed</button>
                    </div>`;
                // Re-attach event listener to the new button
                document.getElementById('btn-proceed-withdraw').addEventListener('click', document.getElementById('btn-proceed-withdraw').onclick);
            }, 3000);
        });

        // Ensure updateUI is called once at start
        updateUI();

    </script>
</body>
</html>
